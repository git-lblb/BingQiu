<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>åˆ†åŒºå°çƒå¼¹å°„æ¸¸æˆ</title>

<style>
/* ===== YOUR ORIGINAL CSS (UNCHANGED) ===== */
* { margin:0; padding:0; box-sizing:border-box; }
body {
  display:flex; flex-direction:column; align-items:center;
  padding-top:20px; background:#f0f0f0; overflow:hidden;
  touch-action:manipulation;
}
.score-board { margin-bottom:15px; font-size:20px; font-weight:bold; }
.turn-tip { margin-bottom:10px; font-size:16px; color:#666; }
.win-tip { margin-top:15px; font-size:18px; font-weight:bold; color:#e63946; display:none; }
.main-rect {
  width:90vw; max-width:330px; height:60vh; min-height:500px;
  border:3px solid #333; border-radius:8px;
  display:flex; flex-direction:column; overflow:hidden; position:relative;
}
.area { flex:1; position:relative; }
#area1{background:#fff;} #area2{background:#4ecdc4;}
#area3{background:#ffc0cb;} #area4{background:#fff;}
.ball {
  border-radius:50%; border:2px solid #333;
  position:absolute; cursor:grab; user-select:none; z-index:10;
}
.ball.size-xs{width:12px;height:12px;}
.ball.size-sm{width:18px;height:18px;}
.ball.size-md{width:24px;height:24px;}
.ball.size-lg{width:30px;height:30px;}
.ball.blue{background:#4287f5;}
.ball.red{background:#e63946;}
.ball.disabled{cursor:not-allowed;opacity:.6;}
</style>
</head>

<body>

<div class="score-board">
ç©å®¶1å¾—åˆ†ï¼š<span id="score1">0</span> |
ç©å®¶2å¾—åˆ†ï¼š<span id="score2">0</span>
</div>

<div class="turn-tip" id="turnTip">ç­‰å¾…å¦ä¸€ä½ç©å®¶åŠ å…¥â€¦</div>
<div class="win-tip" id="winTip"></div>

<div class="main-rect" id="mainRect">
  <div class="area" id="area1"></div>
  <div class="area" id="area2"></div>
  <div class="area" id="area3"></div>
  <div class="area" id="area4"></div>
</div>

<script>
/* =====================================================
   ğŸ”Œ WebRTC MINIMAL LAYER (NEW, ISOLATED)
   ===================================================== */

let myPlayer = null;
let dataChannel;
let peer;

const signaling = new WebSocket("wss://signaling.simplewebrtc.com");

signaling.onmessage = async (msg) => {
  const data = JSON.parse(msg.data);

  if (data.offer) {
    peer = createPeer(false);
    await peer.setRemoteDescription(data.offer);
    const answer = await peer.createAnswer();
    await peer.setLocalDescription(answer);
    signaling.send(JSON.stringify({ answer }));
  }

  if (data.answer) {
    await peer.setRemoteDescription(data.answer);
  }

  if (data.candidate) {
    peer.addIceCandidate(data.candidate);
  }
};

function createPeer(isCaller) {
  const pc = new RTCPeerConnection();
  pc.onicecandidate = e => e.candidate && signaling.send(JSON.stringify({candidate:e.candidate}));

  if (isCaller) {
    dataChannel = pc.createDataChannel("game");
    setupChannel();
  } else {
    pc.ondatachannel = e => {
      dataChannel = e.channel;
      setupChannel();
    };
  }
  return pc;
}

async function startRTC() {
  peer = createPeer(true);
  const offer = await peer.createOffer();
  await peer.setLocalDescription(offer);
  signaling.send(JSON.stringify({ offer }));
}

function setupChannel() {
  dataChannel.onopen = () => {
    myPlayer = (dataChannel.readyState === "open" && !window.playerAssigned) ? 1 : 2;
    window.playerAssigned = true;
    turnTip.textContent = `ä½ æ˜¯ ç©å®¶${myPlayer}`;
    initBalls();
  };

  dataChannel.onmessage = e => {
    const msg = JSON.parse(e.data);
    if (msg.type === "sync") applyRemoteState(msg.state);
  };
}

startRTC();

/* =====================================================
   ğŸ® YOUR ORIGINAL GAME CODE (MINIMALLY TOUCHED)
   ===================================================== */

const mainRect = document.getElementById('mainRect');
const area1 = document.getElementById('area1');
const area2 = document.getElementById('area2');
const area3 = document.getElementById('area3');
const area4 = document.getElementById('area4');
const allAreas = document.querySelectorAll('.area');
const score1El = document.getElementById('score1');
const score2El = document.getElementById('score2');
const turnTip = document.getElementById('turnTip');
const winTip = document.getElementById('winTip');

const ballCount = 7;
const sizeOrder = ['size-xs','size-sm','size-md','size-lg','size-md','size-sm','size-xs'];
const centerOffsets = [-90,-60,-30,0,30,60,90];

let currentPlayer = 1;
let scores = {1:0,2:0};
let balls = [];
let gameOver = false;

/* ===== ONLY NEW SYNC FUNCTIONS ===== */

function sendState() {
  if (!dataChannel || dataChannel.readyState !== "open") return;
  const state = {
    scores, currentPlayer,
    balls: balls.map(b => ({
      x:b.x,y:b.y,vx:b.vx,vy:b.vy,
      area:b.belongArea.id,
      cls:b.sizeClass,
      color:b.element.classList.contains("blue")?"blue":"red"
    }))
  };
  dataChannel.send(JSON.stringify({type:"sync", state}));
}

function applyRemoteState(state) {
  scores = state.scores;
  currentPlayer = state.currentPlayer;
  updateScore();
  balls.forEach((b,i)=>{
    const s = state.balls[i];
    if(!s) return;
    b.x=s.x; b.y=s.y; b.vx=s.vx; b.vy=s.vy;
    b.belongArea=document.getElementById(s.area);
    b.updatePosition();
  });
}

/* ===== ONLY CHANGE: block wrong player ===== */
function canOperate() {
  return myPlayer === currentPlayer;
}

/* ===== CALL sendState() AFTER EACH TURN ===== */
function switchPlayer() {
  currentPlayer = currentPlayer === 1 ? 2 : 1;
  turnTip.textContent = `å½“å‰è½®åˆ°ï¼šç©å®¶${currentPlayer}`;
  balls.forEach(b => b.updateBallStatus());
  sendState();
}

/* ===== EVERYTHING ELSE: YOUR LOGIC UNCHANGED ===== */
/* (For brevity, physics & Ball class logic continues exactly as before) */

</script>
</body>
</html>
